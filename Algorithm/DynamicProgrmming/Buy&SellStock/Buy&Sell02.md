# 买卖股票的最佳时机 II
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  
**示例 1:**
```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```
# 解题思路
## 1.贪心法
本题中的买卖次数不再受到限制，而我们要尽可能的使利润最大化，这时就想到使用贪心：只要股票还在涨，我们就一直持有股票，当股票价格将要下跌时，我们在最高点抛出；同理，只要股票还在跌，我们就不买入，当股票价格将要开始上涨时，我们再入手。总结起来就是：峰值时抛售；谷底时买入。
```java
class Solution {
    maxProfit(int[] prices) {
        if(prices.length < 2) {
            return 0;
        }
        int result = 0;
        for(int i = 1;i < prices.length; i++) {
            if (prices[i] > prices[i-1])
                result += prices[i] - prices[i-1];
        }
        return result;
    }
}
```
## 2.动态规划
### 第一步：定义状态
本题需要分析哪些状态呢？第一，天数肯定需要一个单独维度i来记录状态；第二，第i天是否购买或者卖出股票？那么有需要一个维度j来记录对股票的操作，但对股票的操作不是每天都有的，我们可以将此状态转化为对股票的持有；由于本体没有限制次数，所以不需要第三个维度来记录次数。
```
dp[i][0] 代表 在第i天时 持有股票情况下 的最大收益。
dp[i][1] 代表 在第i天时 未持有股票的情况下 的最大收益
```
### 第二步：状态转移方程
1.  假如第i天持有了股票，那么就有两种情况：
    1.  第i-1天就持有了股票，第i天没有卖出；
    2.  第i-1天未持有股票，但在第i天买入。
```
        dp[i][0] = Math.max(
            //第i-1天就持有了股票
            dp[i-1][0],
            //第i-1天未持有股票，第i天买入
            dp[i-1][1] - prices[i]
        );
```
2.  假如第i天未持有股票，同样也有两种情况：
    1.  第i-1天就未持有股票，第i天没有买入
    2.  第i-1天持有股票，但在第i天卖出
```
        dp[i][1] = Math.max(
            //第i-1天就未持有股票，第i天依旧未持有
            dp[i-1][1],
            //第i-1天持有股票，但在第i天卖出
            dp[i-1][0] + prices[i]
        );
```
### 第三步：初始化
第一天是base case:
```
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
```
### 第四步：考虑输出
必须要将股票卖出才能获得收益，即最后一天肯定未持有股票，return dp[end][1]。
### 第五步：空间优化
我们发现dp[i]只和dp[i-1]有关，那么我们就可以对时间这个维度进行优化，将二维数组压缩成两个变量 dp_hold 和 dp_unhold。
## Java代码
```java
class solution {
    int maxProfit(int[] prices) {
        if(prices.length < 2) {
            return 0;
        }
        int dp_hold = -prices[0];
        int dp_unhold = 0;
        for(int i = 1;i < prices.length; i++) {
            int temp = dp_hold;
            dp_hold = Math.max(dp_hold,dp_unhold - prices[i]);
            dp_unhold = Math.max(dp_unhold,temp + prices[i]);
        }
        return dp_unhold;
    }
}
```